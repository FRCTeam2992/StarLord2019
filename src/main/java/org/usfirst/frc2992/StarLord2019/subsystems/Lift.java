// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2992.StarLord2019.subsystems;


import org.usfirst.frc2992.StarLord2019.Constants;
import org.usfirst.frc2992.StarLord2019.Robot;
import org.usfirst.frc2992.StarLord2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.LimitSwitchNormal;
import com.ctre.phoenix.motorcontrol.LimitSwitchSource;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.Timer;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Lift extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public WPI_TalonSRX liftTalon;
    private WPI_VictorSPX liftVictor;

    private final int liftMaxTravel = 40;//44?  //Inches we can move from bottom to top

    public boolean moving;

    private Timer timer;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public Lift() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        liftTalon = new WPI_TalonSRX(7);
        liftTalon.setNeutralMode(NeutralMode.Brake);
        liftTalon.configClearPositionOnLimitR(true, 10); //(clear Posn, TimeoutMS

        liftVictor = new WPI_VictorSPX(8);
        liftVictor.setNeutralMode(NeutralMode.Brake);
        liftVictor.follow(liftTalon);
        liftVictor.setInverted(InvertType.OpposeMaster);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        liftTalon.setSensorPhase(false);
        liftTalon.configClosedloopRamp(.1);// (seconds from min to full power)
        liftTalon.configClosedLoopPeakOutput(0, 0.3);
        liftTalon.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen);
        liftTalon.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen);

        /*
        liftTalon.config_kP(0, .243);// (slot, value)
        liftTalon.config_kI(0, 0.0019);
        liftTalon.config_kD(0, 10.35);
        liftTalon.config_kF(0, 0);
        liftTalon.config_IntegralZone(0, 150);
        liftTalon.configAllowableClosedloopError(0, 20, 50);// (slot, error, timeoutMs)
        */
        //liftTalon.set(ControlMode.Position, 4096*8.5);
        //liftTalon.set(ControlMode.Position, 4096*2, DemandType.ArbitraryFeedForward, .07);

    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new LiftStop());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        if(Robot.oi.limitSwitchOverrideBtn.get()){
            liftTalon.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.Disabled);
            liftTalon.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.Disabled);
        } else {
            liftTalon.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen);
            liftTalon.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen);
        }
 
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void liftMove(double speed){
        if(!moving){
            timer.reset();
            timer.start();
        }
        moving = true;
        //if(liftTalon.configForwardLimitSwitchSource(type, normalOpenOrClose))
        //Wait to move so hatch extend solenoid can retract
        if(timer.get() >= Constants.liftTimeout || !Robot.hatchIntake.extendPosn){
            liftTalon.set(speed);
        }
        
    }

    public void goToHeight(double height){
        moving = true;

        height = Math.max(0, Math.min(height, liftMaxTravel));

        height += liftTalon.getSelectedSensorPosition();
        
        liftTalon.set(ControlMode.Position, height);
    }

    public void liftStop(){
        liftTalon.set(0);
        moving = false;
    }

    public void holdPosn(){
        //height = Robot.driveTrain.convertEncoderTicks(height);
        double height = liftTalon.getSelectedSensorPosition();

        liftTalon.set(ControlMode.Position, height);

        moving = false;
    }

    public double ChooseCargoHeight(int floor){
        switch (floor){
            case 0: return Constants.cargoGroundHeight;

            case 1: return Constants.cargoLoadHeight;

            case 2: return Constants.bottomRocketCargoHeight;

            case 3: return Constants.middleRocketCargoHeight;

            case 4: return Constants.topRocketCargoHeight;

            default: return Constants.cargoGroundHeight;
        }
    }

    public double ChooseHatchHeight(int Floor){
        switch (Floor){
            case 2: return Constants.bottomRocketHatchHeight;

            case 3: return Constants.middleRocketHatchHeight;
            
            case 4: return Constants.topRocketHatchHeight;
            
            default: return Constants.bottomRocketHatchHeight;
        }
    }

    public int convertEncoderTicks(double inches){
        return (int) Math.round(((inches* 4096) /8));
    }

}

