// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2992.StarLord2019.subsystems;


import org.usfirst.frc2992.StarLord2019.Constants;
import org.usfirst.frc2992.StarLord2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import com.kauailabs.navx.frc.AHRS;
import java.util.ArrayList;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.Solenoid;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public WPI_TalonSRX rightTalonDrive;
    public WPI_TalonSRX leftTalonDrive;
    private WPI_VictorSPX leftVictorDrive1;
    private WPI_VictorSPX leftVictorDrive2;
    private WPI_VictorSPX rightVictorDrive1;
    private WPI_VictorSPX rightVictorDrive2;
    private Solenoid driveGearShift;
    private WPI_TalonSRX talon6;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public final AHRS navx;
    
    public PIDController lDistPID, rDistPID;
    

    //right distance pid
    //double rkp = rightTalonDrive.config_kP(slotIdx, value, timeOutMs);
    //double rki = rightTalonDrive.config_kI(slotIdx, value, timeOutMs);
    //double rkd = rightTalonDrive.config_kD(slotIdx, value, timeOutMs);
    
    //left distance pid
    //double lkp = leftTalonDrive.config_kP(slotIdx, value, timeOutMs);
    //double lki = leftTalonDrive.config_kI(slotIdx, value, timeOutMs);
    //double lkd = leftTalonDrive.config_kD(slotIdx, value, timeOutMs);
    
    
    public PIDController turnPID;
    //public ArrayList<WPI_TalonSRX> driveMotors;
    public RotatePID turn;
    
        //DriveTrain PID
        final double tkp = 0;
        final double tki = 0;
        final double tkd = 0;

        //Gyro PID
        double gError = 0;
        double gkp = .01;
        double gkd = 0;


    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        rightTalonDrive = new WPI_TalonSRX(4);

        leftTalonDrive = new WPI_TalonSRX(1);
        
        leftVictorDrive1 = new WPI_VictorSPX(2);
        
        leftVictorDrive2 = new WPI_VictorSPX(3);
        
        rightVictorDrive1 = new WPI_VictorSPX(5);

        rightVictorDrive2 = new WPI_VictorSPX(6);
        
        navx = new AHRS(SPI.Port.kMXP);

        
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        talon6 = new WPI_TalonSRX(6);
        talon6.setName("Talon6");
        talon6.setSubsystem("testing");
        LiveWindow.add(talon6);
        talon6.setSensorPhase(true);
        talon6.set(ControlMode.Position, Constants.driveEncDist *5);
        
        talon6.configClosedloopRamp(.1);// (seconds from min to full power)
        talon6.config_kP(0, .243);// (slot, value)
        talon6.config_kI(0, 0.0019);
        talon6.config_kD(0, 10.35);
        talon6.config_kF(0, 0);
        talon6.config_IntegralZone(0, 150);
        talon6.configAllowableClosedloopError(0, 20, 50);// (slot, error, timeoutMs)

    
        driveGearShift = new Solenoid(0,0);//(device #, port #)
        driveGearShift.setSubsystem("DriveTrain");
        driveGearShift.setName("driveGearShift");
        LiveWindow.add(driveGearShift);

        rightTalonDrive.setInverted(true);
        rightTalonDrive.setSubsystem("DriveTrain");
        rightTalonDrive.setName("rightTalonDrive");
        LiveWindow.add(rightTalonDrive);
        rightTalonDrive.setSafetyEnabled(false);
    
        leftTalonDrive.setInverted(false);
        leftTalonDrive.setSubsystem("DriveTrain");
        leftTalonDrive.setName("leftTalonDrive");
        LiveWindow.add(leftTalonDrive);
        leftTalonDrive.setSafetyEnabled(false);

        rightVictorDrive1.follow(rightTalonDrive);
        rightVictorDrive1.setInverted(InvertType.FollowMaster);

        rightVictorDrive2.follow(rightTalonDrive);
        rightVictorDrive2.setInverted(InvertType.FollowMaster);

        leftVictorDrive1.follow(leftTalonDrive);
        leftVictorDrive1.setInverted(InvertType.FollowMaster);

        leftVictorDrive2.follow(leftTalonDrive);
        leftVictorDrive2.setInverted(InvertType.FollowMaster);
       
        //current limiting for the Talons
        rightTalonDrive.configPeakCurrentLimit(55,0); //(peakCurrentAmps, timeout)
        rightTalonDrive.configPeakCurrentDuration(200, 0);//(time in ms after reaches threshold before limiting, timeout)
        rightTalonDrive.configContinuousCurrentLimit(55,0);//(currentAmps can go after limited, timeout)
        rightTalonDrive.enableCurrentLimit(true);

        leftTalonDrive.configPeakCurrentLimit(55,0);
        leftTalonDrive.configPeakCurrentDuration(200,0);
        leftTalonDrive.configContinuousCurrentLimit(55,0);
        leftTalonDrive.enableCurrentLimit(true);

        //voltage ramping (basically 48 volts/sec)
        rightTalonDrive.configOpenloopRamp(0.1, 0);// (seconds from 0-full volts, timeout in millisec do 0);
        leftTalonDrive.configOpenloopRamp(0.1,0);

        //Turn PID Controller, use bc navx not connected to Talon for Talon PID
        turn = new RotatePID(leftTalonDrive, rightTalonDrive);
        //driveMotors = new ArrayList<WPI_TalonSRX>();
        //driveMotors.add(leftTalonDrive);
        //driveMotors.add(rightTalonDrive);
        turnPID = new PIDController(tkp, tki, tkd, navx, turn);


    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new driveSticks());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void allStop(){
        rightTalonDrive.set(0);
        leftTalonDrive.set(0);
    }

    public void tankDrive(double left, double right){
        //RECOMMENDED DO NOT USE AVG STUFF, DOESNT WORK WELL
        //double lrAvg = (left+right)/2.0;
    	
    	// Dampen turns by pushing left and right powers slightly toward the average
    	
    	//left = (left + 0.8 * left + 1.2 * lrAvg) / 3.0;
    	//right = (right + 0.8 * right + 1.2 * lrAvg) / 3.0;
    	
        right = Math.max(-1.0, Math.min(1.0,  right));
        left = Math.max(-1.0, Math.min(1.0,  left));

        rightTalonDrive.set(right);
        //talon6.set(right);
        leftTalonDrive.set(left);
    }

    public void highGear(){
        driveGearShift.set(true);
    }
    

    public void lowGear(){
        driveGearShift.set(false);
    }

    public double getDist(double h1, double h2, double a1, double a2){
        return (h2 - h1) / Math.tan(a1 + a2);
    }

    public void SmartDriveDist(double distance, double speed){  //For PID drive no gyro
        rightTalonDrive.setNeutralMode(NeutralMode.Brake);
        leftTalonDrive.setNeutralMode(NeutralMode.Brake);

        rightTalonDrive.setSelectedSensorPosition(0, 0, 1); //(sensor position, pid Id, timeoutMs)
        leftTalonDrive.setSelectedSensorPosition(0, 0, 1);

        //convert inches to encoder ticks
        distance = convertEncoderTicks(distance);

        rightTalonDrive.set(ControlMode.Position, distance);
        leftTalonDrive.set(ControlMode.Position, distance);
    }

    public void SmartDriveGyro(double heading, double power){  //For PID drive with gyro
        power = Math.abs(power);

        double gyroError = calcGyroError(heading);
        double pGyro = gError - gyroError;

    	System.out.println("GyroError:  " + gyroError);
    	lDistPID.setOutputRange(-power - gkp*gyroError + gkd *pGyro, power - gkp*gyroError + gkd *pGyro);
    	rDistPID.setOutputRange(-power + gkp*gyroError - gkd *pGyro, power + gkp*gyroError - gkd *pGyro);
    	System.out.println("Left power:  " + (power-gkp*gyroError - gkd *pGyro));
    	System.out.println("Right power:  " + (power + gkp*gyroError + gkd *pGyro));
    	gError = gyroError;
    }

    public void SmartDriveRot(double degrees){ //For PID rotate

        //Need to do calculations for degrees to encoder ticks
        rightTalonDrive.set(ControlMode.Position, -degrees); 
        leftTalonDrive.set(ControlMode.Position, degrees);

        turnPID.setOutputRange(-0.8, 0.8);
        turnPID.setInputRange(-180.0, 180.0);
        turnPID.setContinuous();
        turnPID.setAbsoluteTolerance(10);
        turnPID.setSubsystem("DriveTrain");
        turnPID.setName("turnPID");
        LiveWindow.add(turnPID);
        
        turnPID.disable();
    }

    private double calcGyroError(double heading){ //For PID- finding error
        double error = 0;
        error = scaleAngle(navx.getYaw()) - heading;
        if(Math.abs(error) >= 1){
            return error;
        } else {
            return 0;
        }

    }
    private double scaleAngle(double angle){ //For PID make sure turning goes shortest distance (think circle)
        while(angle > 180){
            angle -= 360;
        }
        while(angle < -180){
            angle += 360;
        }
        return angle;
    }

    public boolean driveDone(double dist){
        
        if(rightTalonDrive.getSelectedSensorPosition() == dist && leftTalonDrive.getSelectedSensorPosition() == dist){
            return true;
        } else {
            return false;
        }
    }
    public int convertEncoderTicks(double inches){
        int ticks = 0;
        //converting inches (2*pi*r) times the number of ticks/revolution
        ticks = (int) Math.round((inches * Constants.driveEncDist) / (2 * 3.141592 * 3)); 
        return ticks;
    }


}