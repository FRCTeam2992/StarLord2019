// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2992.StarLord2019.subsystems;


import org.usfirst.frc2992.StarLord2019.Constants;
import org.usfirst.frc2992.StarLord2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.cscore.CameraServerJNI;
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import com.kauailabs.navx.frc.AHRS;
import java.util.ArrayList;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.Solenoid;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public WPI_TalonSRX rightTalonDrive;
    public WPI_TalonSRX leftTalonDrive;
    private WPI_VictorSPX leftVictorDrive1;
    private WPI_VictorSPX leftVictorDrive2;
    private WPI_VictorSPX rightVictorDrive1;
    private WPI_VictorSPX rightVictorDrive2;
    private Solenoid driveGearShift;
    //private WPI_TalonSRX talon6;

    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public final AHRS navx;
    
    public PIDController turnPID;
    
    public RotatePID turn;
    
    //DriveTurn PID
    final double tkp = 0;
    final double tki = 0;
    final double tkd = 0;

    //Gyro PID
    double gError = 0;
    double gkp = .01;
    double gkd = 0;


    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        rightTalonDrive = new WPI_TalonSRX(1);

        leftTalonDrive = new WPI_TalonSRX(4);
        
        leftVictorDrive1 = new WPI_VictorSPX(5);
        
        leftVictorDrive2 = new WPI_VictorSPX(6);
        
        rightVictorDrive1 = new WPI_VictorSPX(2);

        rightVictorDrive2 = new WPI_VictorSPX(3);
        
        navx = new AHRS(SPI.Port.kMXP);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        /*
        talon6 = new WPI_TalonSRX(6);
        talon6.setName("Talon6");
        talon6.setSubsystem("testing");
        LiveWindow.add(talon6);
        talon6.setSensorPhase(true);
        talon6.set(ControlMode.Position, Constants.liftEncDist *5);
        
        talon6.configClosedloopRamp(.1);// (seconds from min to full power)
        talon6.config_kP(0, .243);// (slot, value)
        talon6.config_kI(0, 0.0019);
        talon6.config_kD(0, 10.35);
        talon6.config_kF(0, 0);
        talon6.config_IntegralZone(0, 150);
        talon6.configAllowableClosedloopError(0, 20, 50);// (slot, error, timeoutMs)
        */
    
        driveGearShift = new Solenoid(0,0);//(device #, port #)
        driveGearShift.setSubsystem("DriveTrain");
        driveGearShift.setName("driveGearShift");
        LiveWindow.add(driveGearShift);

        rightTalonDrive.setInverted(false);
        rightTalonDrive.setSensorPhase(true);
        rightTalonDrive.setSubsystem("DriveTrain");
        rightTalonDrive.setName("rightTalonDrive");
        LiveWindow.add(rightTalonDrive);
        rightTalonDrive.setSafetyEnabled(false);
    
        leftTalonDrive.setInverted(true);
        leftTalonDrive.setSensorPhase(true);
        leftTalonDrive.setSubsystem("DriveTrain");
        leftTalonDrive.setName("leftTalonDrive");
        LiveWindow.add(leftTalonDrive);
        leftTalonDrive.setSafetyEnabled(false);

        rightVictorDrive1.follow(rightTalonDrive);
        rightVictorDrive1.setInverted(InvertType.FollowMaster);

        rightVictorDrive2.follow(rightTalonDrive);
        rightVictorDrive2.setInverted(InvertType.FollowMaster);

        leftVictorDrive1.follow(leftTalonDrive);
        leftVictorDrive1.setInverted(InvertType.FollowMaster);

        leftVictorDrive2.follow(leftTalonDrive);
        leftVictorDrive2.setInverted(InvertType.FollowMaster);
       
        //current limiting for the Talons
        rightTalonDrive.configPeakCurrentLimit(55,0); //(peakCurrentAmps, timeout)
        rightTalonDrive.configPeakCurrentDuration(200, 0);//(time in ms after reaches threshold before limiting, timeout)
        rightTalonDrive.configContinuousCurrentLimit(55,0);//(currentAmps can go after limited, timeout)
        rightTalonDrive.enableCurrentLimit(true);

        leftTalonDrive.configPeakCurrentLimit(55,0);
        leftTalonDrive.configPeakCurrentDuration(200,0);
        leftTalonDrive.configContinuousCurrentLimit(55,0);
        leftTalonDrive.enableCurrentLimit(true);

        //voltage ramping (basically 48 volts/sec)
        rightTalonDrive.configOpenloopRamp(0.2, 0);// (seconds from 0-full volts, timeout in millisec do 0);
        leftTalonDrive.configOpenloopRamp(0.2,0);

        //DriveTrain PID Values
        rightTalonDrive.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder);
        leftTalonDrive.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder);

        rightTalonDrive.configClosedloopRamp(.1);// (seconds from min to full power)
        rightTalonDrive.config_kP(0, .2);// (slot, value)
        rightTalonDrive.config_kI(0, 0);
        rightTalonDrive.config_kD(0, 0);
        rightTalonDrive.config_kF(0, 0);
        rightTalonDrive.configAllowableClosedloopError(0, 200, 500);// (slot, error, timeoutMs)
        //rightTalonDrive.configClosedLoopPeakOutput(0,.5);

        leftTalonDrive.configClosedloopRamp(.1);// (seconds from min to full power)
        leftTalonDrive.config_kP(0, .2);// (slot, value)
        leftTalonDrive.config_kI(0, 0);
        leftTalonDrive.config_kD(0, 0);
        leftTalonDrive.config_kF(0, 0);
        leftTalonDrive.configAllowableClosedloopError(0, 200, 500);// (slot, error, timeoutMs)
        //leftTalonDrive.configClosedLoopPeakOutput(0, .5);

        //rightTalonDrive.set(ControlMode.Position, convertEncoderTicks(12));
        //leftTalonDrive.set(ControlMode.Position, convertEncoderTicks(12));
        
        //SmartDriveDist(120, 0.5);

        //Turn PID Controller, use bc navx not connected to Talon for Talon PID

        turn = new RotatePID(leftTalonDrive, rightTalonDrive);
        turnPID = new PIDController(tkp, tki, tkd, navx, turn);

        turnPID.setOutputRange(-0.8, 0.8);
        turnPID.setInputRange(-180.0, 180.0);
        turnPID.setContinuous();
        turnPID.setAbsoluteTolerance(10);
        turnPID.setSubsystem("DriveTrain");
        turnPID.setName("turnPID");
        LiveWindow.add(turnPID);
        
        turnPID.disable();


    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new driveSticks());
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void allStop(){
        rightTalonDrive.set(0);
        leftTalonDrive.set(0);
    }

    public void tankDrive(double left, double right){
        //RECOMMENDED DO NOT USE AVG STUFF, DOESNT WORK WELL
        //double lrAvg = (left+right)/2.0;
    	// Dampen turns by pushing left and right powers slightly toward the average
    	//left = (left + 0.8 * left + 1.2 * lrAvg) / 3.0;
        //right = (right + 0.8 * right + 1.2 * lrAvg) / 3.0;

    	
        right = Math.max(-1.0, Math.min(1.0,  right));
        left = Math.max(-1.0, Math.min(1.0,  left));

        rightTalonDrive.set(ControlMode.PercentOutput, right);
        leftTalonDrive.set(ControlMode.PercentOutput,left);
    }

    public void arcadeDrive(double moveValue, double rotateValue){
	   
        double leftMotorSpeed;
        double rightMotorSpeed;
 
         if (moveValue > 0.0) {
           if (rotateValue > 0.0) {
             leftMotorSpeed = Math.max(moveValue, rotateValue);
             rightMotorSpeed = moveValue - rotateValue;
           } else {
             leftMotorSpeed = moveValue + rotateValue;
             rightMotorSpeed = Math.max(moveValue, -rotateValue);
           }
         } else {
           if (rotateValue > 0.0) {
             leftMotorSpeed = moveValue + rotateValue;
             rightMotorSpeed = -Math.max(-moveValue, rotateValue);
           } else {
             leftMotorSpeed = -Math.max(-moveValue, -rotateValue);
             rightMotorSpeed = moveValue - rotateValue;
           }
         }
 
         tankDrive(leftMotorSpeed, rightMotorSpeed);
    }

    public void highGear(){
        driveGearShift.set(true);
    }
    

    public void lowGear(){
        driveGearShift.set(false);
    }

    //Method for VP
    public double getDist(double h1, double h2, double a1, double a2){
        return (h2 - h1) / Math.tan(a1 + a2);
    }

    public void SmartDriveDist(double distance, double speed){  //For PID drive no gyro
        rightTalonDrive.setNeutralMode(NeutralMode.Brake);
        leftTalonDrive.setNeutralMode(NeutralMode.Brake);

        double rEncVal = rightTalonDrive.getSelectedSensorPosition(0); //(sensor position)
        double lEncVal = leftTalonDrive.getSelectedSensorPosition(0);

        //convert inches to encoder ticks
        double rDistance = convertEncoderTicks(distance) + rEncVal;
        double lDistance = convertEncoderTicks(distance) + lEncVal;

        rightTalonDrive.configClosedLoopPeakOutput(0, speed);
        leftTalonDrive.configClosedLoopPeakOutput(0, speed);

        rightTalonDrive.set(ControlMode.Position, rDistance);
        leftTalonDrive.set(ControlMode.Position, lDistance);
    }

    public void SmartDriveGyro(double heading, double power, double dist){  //For PID drive with gyro
        power = Math.abs(power);

        double gyroError = calcGyroError(heading);
        double pGyro = gError - gyroError;

        System.out.println("GyroError:  " + gyroError);
        //setting an % power output range for the right and left drive motors
        //these methods come through the Talons

        if(dist >0){
            leftTalonDrive.configClosedLoopPeakOutput(0, power - gkp*gyroError + gkd *pGyro);
            rightTalonDrive.configClosedLoopPeakOutput(0, power + gkp*gyroError - gkd *pGyro);    
        } else{
            leftTalonDrive.configClosedLoopPeakOutput(0, power + gkp*gyroError + gkd *pGyro);
            rightTalonDrive.configClosedLoopPeakOutput(0, power - gkp*gyroError - gkd *pGyro);
        }
        
        //leftTalonDrive.configPeakOutputReverse(-power - gkp*gyroError + gkd *pGyro);
        
        //rightTalonDrive.configPeakOutputReverse(-power + gkp*gyroError - gkd *pGyro);
    	System.out.println("Left power:  " + (power-gkp*gyroError - gkd *pGyro));
    	System.out.println("Right power:  " + (power + gkp*gyroError + gkd *pGyro));
    	gError = gyroError;
    }

    public void SmartDriveRot(double degrees){ //For PID rotate

        //Need to do calculations for degrees to encoder ticks
        //rightTalonDrive.set(ControlMode.Position, -degrees); 
        //leftTalonDrive.set(ControlMode.Position, degrees);

        turnPID.setSetpoint(degrees);

    }

    private double calcGyroError(double heading){ //For PID- finding error
        double error = 0;
        error = scaleAngle(navx.getYaw()) - heading;
        if(Math.abs(error) >= 1){
            return error;
        } else {
            return 0;
        }

    }
    private double scaleAngle(double angle){ //For PID make sure turning goes shortest distance (think circle)
        while(angle > 180){
            angle -= 360;
        }
        while(angle < -180){
            angle += 360;
        }
        return angle;
    }

    public int convertEncoderTicks(double inches){
        int ticks = 0;
        //diameter[6] * Pi[3.14] / PPR (pulse/rev)[128] / GearBox constant[3] / gear ratio[60:24]
        //[4] must account for QUADrature encoders
        ticks = (int)Math.round(inches * ((128 * 60 * 3 * 4) / (6 * 3.14 * 24)));
        //ticks = (int) Math.round((inches * Constants.liftEncDist) / (2 * 3.141592 * 3));
        
        //By pushing robot 20 feet - found about 205.960 ticks/inch. Use Dimensional Analysis
        //all of these return about the came # ticks for 1 rotation, but 
        //wheels not moving same amount (enc readings are about 2,000 off)
        //ticks = (int)Math.round(inches * 205.960);

        return ticks;
    }

}